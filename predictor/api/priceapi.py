from typing import Dict

import pytz
from fastapi import FastAPI, Query
from fastapi.responses import RedirectResponse
import datetime


app = FastAPI(title="EPEX day-ahead prediction API")


@app.get("/")
def api_docs():
    return RedirectResponse("/docs")



import predictor.model.pricepredictor as pp

class Prices:
    predictor : pp.PricePredictor = pp.PricePredictor(testdata=True)
    last_weather_update : datetime.datetime = datetime.datetime(1980, 1, 1)
    last_price_update : datetime.datetime = datetime.datetime(1980, 1, 1)

    cachedprices : Dict[datetime.datetime, float]
    cachedeval : Dict[datetime.datetime, float]

    def __init__(self):
        pass

    def prices(self, hours : int = -1, fixedPrice : float = 0.0, taxPercent : float = 0.0, startTs : datetime.datetime|None = None, evaluation : bool = False):
        tzgerman = pytz.timezone("Europe/Berlin")

        if startTs is None:
            startTs = datetime.datetime.now(tz=tzgerman)
            startTs = startTs.replace(minute=0, second=0, microsecond=0)
        else:
            if startTs.tzinfo is None:
                startTs = startTs.astimezone(tzgerman)
        
        endTs = datetime.datetime(2999, 1, 1, tzinfo=tzgerman)
        if hours >= 0:
            endTs = startTs + datetime.timedelta(hours=hours)


        currts = datetime.datetime.now()
        weather_age = currts - self.last_weather_update
        price_age = currts - self.last_price_update
        retrain = False
        if weather_age.seconds > 60 * 60 * 8: # update weather every 4 hours
            self.predictor.refresh_forecasts()
            self.last_weather_update = currts
            retrain = True
        if price_age.seconds > 60 * 15: # update prices every 15 mins
            self.predictor.refresh_prices()
            self.last_price_update = currts
            retrain = True
        if retrain:
            self.predictor.train()
            self.cachedprices = self.predictor.predict()
            self.cachedeval = self.predictor.predict(estimateAll=True)
        
        prices = self.cachedprices if evaluation is False else self.cachedeval

        result = []
        for dt in sorted(prices.keys()):
            if dt < startTs:
                continue
            if dt > endTs:
                continue
            formatted = dt.astimezone(tzgerman).isoformat()
            price = prices[dt] / 10.0 # to ct/kWh
            total = (price + fixedPrice) * (1 + taxPercent / 100.0)
            result.append(
                {
                    "startsAt": formatted,
                    "total": round(total, 2)
                }
            )

        return { "prices": result }


pricesHandler = Prices()
@app.get("/prices")
def get_prices(
    hours : int = Query(-1, description="How many hours to predict"),
    fixedPrice : float = Query(0.0, description="Add this fixed amount to all prices (ct/kWh)"),
    taxPercent : float = Query(0.0, description="Tax % to add to the final price"),
    startTs : datetime.datetime|None = Query(None, description="Start output from this time. At most ~60 days"),
    evaluation : bool = Query(False, description="Switches to evaluation mode. All values will be generated by the model, instead of only future values. Useful to evaluate model performance.")):
    """
    Get price prediction
    """
    return pricesHandler.prices(hours, fixedPrice, taxPercent, startTs, evaluation)


    
